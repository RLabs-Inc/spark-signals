# spark-signals Rust Implementation Audit

**Date:** January 24, 2026
**Auditors:** 4-agent parallel reconnaissance squad
**Codebase:** ~9,260 lines Rust across core reactivity, primitives, collections
**Tests:** 255 unit tests + 46 doctests = 301 total (all passing)

---

## Executive Summary

| Area | Status | Action Required |
|------|--------|-----------------|
| Core Reactivity | ✅ Excellent | None |
| TS API Compliance | ⚠️ 88% | Low priority |
| Memory Safety | ❌ Critical bugs | **HIGH PRIORITY** |
| Test Integrity | ❌ 3 hollow tests | **HIGH PRIORITY** |

The reactive algorithm is correct. The issues are around cleanup/memory and test integrity.

---

## 1. TS COMPLIANCE SCOUT REPORT

### 1.1 Fully Compliant (100%)

- [ ] **Constants & Flags** - All type/status flags match TS exactly
- [ ] **Scope Management** - effectScope, getCurrentScope, onScopeDispose all present
- [ ] **MAYBE_DIRTY Optimization** - Correctly implemented with version tracking

### 1.2 Compliant with Rust Adaptations (Acceptable)

These are intentional Rust idioms, not bugs:

| TypeScript | Rust | Reason |
|------------|------|--------|
| `signal.value = 5` | `signal.set(5)` | Rust has no property syntax |
| `signal.value` | `signal.get()` | Method calls for clarity |
| `effect.sync()` | `effect_sync()` | Standalone functions |
| `createSelector()` | `create_selector()` | snake_case convention |
| `bind(signal\|getter\|value)` | `bind()`, `bind_getter()`, `bind_value()` | No function overloading |

### 1.3 Missing APIs (Should Add)

- [ ] `disconnectDerived()` - Public API for manual derived cleanup
- [ ] `createDerived()` - Low-level derived creation for advanced users
- [ ] `signals()` - Batch signal creation helper
- [ ] `hasSlot()` - Check if slot has value
- [ ] `cleanupSelector()` - Manual selector cleanup
- [ ] `toRaw()` - Get raw value from reactive wrapper
- [ ] `isReactive()` - Check if value is reactive

### 1.4 Intentionally Omitted (Acceptable)

- [ ] `ReactiveDate` - DOM-specific, not needed in Rust
- [ ] `state()` / `proxy()` - Rust doesn't have Proxy
- [ ] `reactiveProps()` - Framework-specific helper

### 1.5 API Differences Summary

| Category | Conformance |
|----------|-------------|
| Constants & Flags | 100% |
| Signal API | 95% |
| Derived API | 85% |
| Effect API | 90% |
| Binding API | 85% |
| Selector | 95% |
| Scope | 100% |
| Slot | 95% |
| Collections | 67% |
| **Overall** | **~88%** |

---

## 2. CODE SMELL HUNTER REPORT

### 2.1 CRITICAL - Hollow Tests (No Assertions)

These tests pass but don't actually test anything:

#### Test 1: `flush_sync_runs_pending_effects`
**File:** `src/reactivity/scheduling.rs:350-376`

```rust
#[test]
fn flush_sync_runs_pending_effects() {
    // ... setup effect with run_count ...

    assert_eq!(run_count.get(), 0);

    flush_sync();

    // Effect should have run (via update() method)
    // Note: Currently update() returns false and doesn't run the function
    // We need to fix this - effects should run their function in update()
    // ^^^ NO ASSERTION AFTER THIS COMMENT ^^^
}
```

**Problem:** Comment explicitly says "We need to fix this" but test has no assertion verifying the fix.

- [ ] **FIX:** Add `assert_eq!(run_count.get(), 1);` after flush_sync OR mark as `#[ignore]`

---

#### Test 2: `max_flush_count_prevents_infinite_loop`
**File:** `src/reactivity/scheduling.rs:378-383`

```rust
#[test]
fn max_flush_count_prevents_infinite_loop() {
    // This test is tricky - we'd need an effect that keeps triggering itself
    // For now, just verify the constant exists
    assert_eq!(MAX_FLUSH_COUNT, 1000);
}
```

**Problem:** Only verifies constant exists. Doesn't test infinite loop prevention at all.

- [ ] **FIX:** Implement actual infinite loop test OR rename to `max_flush_count_constant_exists`

---

#### Test 3: `schedule_effect_in_batch_defers_execution`
**File:** `src/reactivity/scheduling.rs:385-409`

```rust
#[test]
fn schedule_effect_in_batch_defers_execution() {
    // ... setup ...

    // Enter batch
    with_context(|ctx| ctx.enter_batch());

    // Schedule effect
    schedule_effect_inner(effect.clone());

    // Effect should not have run yet (we're in a batch)
    // Note: This assertion depends on implementation details
    // ^^^ ZERO ASSERTIONS ^^^

    // Exit batch - this should trigger flush in real implementation
    with_context(|ctx| ctx.exit_batch());
    // ^^^ ALSO NO ASSERTION ^^^
}
```

**Problem:** Zero assertions in entire test. Just sets up state and exits.

- [ ] **FIX:** Add assertions: `assert_eq!(run_count.get(), 0)` before exit, `assert_eq!(run_count.get(), 1)` after

---

### 2.2 MEDIUM - Acknowledged Optimization Gap

**File:** `src/primitives/selector.rs:483`

```rust
// The O(2) optimization: item3 shouldn't need to run
// But for now, let's just verify the feature works at all
```

- [ ] **FIX:** Implement full O(2) optimization verification in tests

---

### 2.3 MEDIUM - Conservative MAYBE_DIRTY Handling

**File:** `src/reactivity/tracking.rs:733`

```rust
// Maybe dirty (treated as dirty for now)
reaction.mark_maybe_dirty();
assert!(is_dirty(&*reaction));
```

- [ ] **VERIFY:** Confirm this is intentional behavior (may cause unnecessary effect reruns)

---

### 2.4 LOW - Unwraps in Production Code

These are in known-safe contexts but could be improved:

- [ ] `src/collections/map.rs:294` - `self.data.get(&key).unwrap()`
- [ ] `src/primitives/derived.rs:100` - `.expect("derived not initialized")`
- [ ] `src/primitives/derived.rs:115` - `.expect("derived fn disposed")`

---

### 2.5 Patterns That Passed (Good Signs)

- No TODO/FIXME comments in production code
- No `panic!()` in production code
- No `unimplemented!()` or `todo!()` macros
- No empty function bodies
- No stub implementations

---

## 3. MEMORY SAFETY AGENT REPORT

### 3.1 CRITICAL - Selector Dispose Never Called

**File:** `src/primitives/selector.rs:326-332`

```rust
_dispose: Rc<RefCell<Option<Box<dyn FnOnce()>>>>,
```

**Problem:** The `_` prefix indicates intentionally unused. When Selector drops, the internal effect is never disposed.

**Impact:** Memory grows with selector creation count. Internal effects accumulate as zombies.

**Evidence:**
- Line 239-324: Effect created but dispose closure never invoked
- Line 331: Stored in `_` field (intentionally unused)
- No `Drop` impl for Selector

- [ ] **FIX:** Implement `Drop` for Selector that calls dispose:
```rust
impl<T, K> Drop for Selector<T, K> {
    fn drop(&mut self) {
        if let Some(dispose) = self._dispose.borrow_mut().take() {
            dispose();
        }
    }
}
```

---

### 3.2 CRITICAL - Selector Weak ptr_eq Bug (Quadratic Growth)

**File:** `src/primitives/selector.rs:56-77`

```rust
impl PartialEq for SubscriberEntry {
    fn eq(&self, other: &Self) -> bool {
        match (self.reaction.upgrade(), other.reaction.upgrade()) {
            (Some(a), Some(b)) => Rc::ptr_eq(&a, &b),
            _ => false,
        }
    }
}
```

**Problem:** Each `upgrade()` creates a NEW `Rc`, so `Rc::ptr_eq()` of two upgraded Weak references **always returns false** for the same underlying reaction!

**Impact:** HashSet deduplication fails. Same effect added to subscribers on every re-run → quadratic memory growth.

- [ ] **FIX:** Compare Weak pointers directly using `Weak::ptr_eq`:
```rust
impl PartialEq for SubscriberEntry {
    fn eq(&self, other: &Self) -> bool {
        Weak::ptr_eq(&self.reaction, &other.reaction)
    }
}
```

And update Hash implementation:
```rust
impl Hash for SubscriberEntry {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.reaction.as_ptr().hash(state)
    }
}
```

---

### 3.3 MAJOR - Dead Weak References Accumulate

**File:** `src/core/types.rs:183-185`

```rust
fn cleanup_dead_reactions(&self) {
    self.reactions.borrow_mut().retain(|w| w.strong_count() > 0);
}
```

**Problem:** This function exists but **nobody calls it**!

**Impact:** O(n) slowdown as dead reactions accumulate in source reaction lists.

- [ ] **FIX:** Call `cleanup_dead_reactions()` periodically. Options:
  1. Call in `mark_reactions()` every N iterations
  2. Call when reaction count exceeds threshold
  3. Call during `flush_sync()`

---

### 3.4 MAJOR - Scope Doesn't Await Pending Effects

**File:** `src/primitives/scope.rs:139-171`

```rust
pub fn stop(&self) {
    // ... destroys effects ...
    // But doesn't flush pending_reactions first!
}
```

**Problem:** Effects that were scheduled but not yet run are orphaned.

- [ ] **FIX:** Consider calling `flush_sync()` before destroying effects in scope.stop()

---

### 3.5 MODERATE - Effect Cleanup Incomplete

**File:** `src/primitives/effect.rs:364-390`

```rust
pub fn destroy_effect(effect: Rc<EffectInner>, remove_from_parent: bool) {
    // ... lots of cleanup ...
    // But parent reference not explicitly cleared!
}
```

- [ ] **FIX:** Add `*effect.parent.borrow_mut() = None;` to cleanup

---

### 3.6 MODERATE - Effect Tree Unlinking Race

**File:** `src/primitives/effect.rs:287-323`

If `unlink_effect()` fails partway through (panic), the sibling chain breaks but Rcs still exist.

- [ ] **INVESTIGATE:** Add tests for partial unlink failure scenarios

---

### 3.7 LOW - Derived Self-Reference Pattern

**File:** `src/primitives/derived.rs:57-59, 90`

The `self_ref: RefCell<Option<Weak<DerivedInner<T>>>>` pattern is unusual. If upgrade fails, derived can't represent itself in the graph.

- [ ] **DOCUMENT:** Add comment explaining why this is safe OR refactor

---

## 4. REACTIVITY INTEGRITY AGENT REPORT

### 4.1 All Critical Guarantees Met ✅

| Guarantee | Status | Evidence |
|-----------|--------|----------|
| MAYBE_DIRTY skips updates when values unchanged | ✅ | `check_deps_changed()` line 471 |
| Dependency tracking prevents duplicates | ✅ | Version-based deduplication |
| Derived recomputes only when dirty | ✅ | `update_derived_chain()` |
| Effects batched correctly | ✅ | BatchGuard RAII pattern |
| batch() defers until exit | ✅ | `is_batching()` guards |
| untrack() prevents deps | ✅ | Early return in track_read |
| Diamond patterns consistent | ✅ | Topological ordering |
| No glitch states | ✅ | Process deepest to shallowest |
| Effects safe to dispose | ✅ | DESTROYED flag check |
| Equality checks prevent cascades | ✅ | `changed` bool controls notify |

### 4.2 Test Coverage Gaps

- [ ] **Selector with derived source** - TS test exists at `selector.test.ts:162-179`, not ported
- [ ] **Circular dependency explicit test** - Relies on MAX_FLUSH_COUNT panic
- [ ] **Nested untrack** - Basic untrack tested, nested not explicit
- [ ] **Effect modification of deps** - Effect reads signal, signal GC'd mid-execution

### 4.3 Architecture Strengths

- Type erasure via AnySource/AnyReaction traits: ✅ Solid
- RAII patterns for batch/untrack: ✅ Excellent
- Version tracking for deduplication: ✅ Elegant
- Weak references for cycle breaking: ✅ Proper
- Borrow safety ("collect-then-mutate"): ✅ Consistent

---

## 5. ACTION ITEMS SUMMARY

### Priority 1 - Critical (Block Production)

- [ ] **3.2** Fix Selector Weak ptr_eq comparison bug
- [ ] **3.1** Implement Drop for Selector to call dispose
- [ ] **2.1** Fix or mark 3 hollow tests in scheduling.rs

### Priority 2 - High (Before Release)

- [ ] **3.3** Call cleanup_dead_reactions() somewhere
- [ ] **3.4** Scope.stop() should flush pending effects
- [ ] **4.2** Port selector+derived test from TypeScript

### Priority 3 - Medium (Improve Quality)

- [ ] **3.5** Clear parent reference in destroy_effect
- [ ] **3.6** Add tests for effect unlink failure
- [ ] **2.2** Verify full O(2) selector optimization
- [ ] **2.3** Confirm MAYBE_DIRTY conservative behavior is intentional

### Priority 4 - Low (Nice to Have)

- [ ] **1.3** Add missing APIs (disconnectDerived, signals(), hasSlot())
- [ ] **2.4** Replace unwraps with proper error handling
- [ ] **3.7** Document derived self_ref pattern

---

## 6. BENCHMARK BASELINE (To Be Captured)

Run `cargo bench` to capture baseline before fixes:

```
[ ] signal/create
[ ] signal/get
[ ] signal/set
[ ] derived/get_cached
[ ] derived/diamond
[ ] effect/trigger
[ ] selector/o2_change vs naive_on
[ ] stress/chain/depth/1000
[ ] stress/fanout/effects/1000
```

---

## 7. NEXT SESSION CHECKLIST

1. [ ] Run benchmarks, record baseline numbers
2. [ ] Fix selector Weak ptr_eq bug (Priority 1)
3. [ ] Add Selector Drop impl (Priority 1)
4. [ ] Fix hollow tests in scheduling.rs (Priority 1)
5. [ ] Call cleanup_dead_reactions() (Priority 2)
6. [ ] Verify fixes with benchmarks

---

*Document generated by 4-agent audit squad reconnaissance mission*
